(self.webpackChunktech_details=self.webpackChunktech_details||[]).push([[8672],{1504:function(t,e,a){"use strict";var n=a(67294),r=a(21140),l=a.n(r);l().initialize({startOnLoad:!0});e.Z=function(t){var e=t.chart;return(0,n.useEffect)((function(){l().contentLoaded()}),[]),n.createElement("div",{className:"mermaid"},e)}},31856:function(t,e,a){"use strict";a.r(e),a.d(e,{frontMatter:function(){return i},contentTitle:function(){return m},metadata:function(){return p},toc:function(){return s},default:function(){return u}});var n=a(22122),r=a(19756),l=(a(67294),a(3905)),o=(a(1504),["components"]),i={hide_title:!0,sidebar_label:"PX4 Dynamic Control Allocation"},m="PX4 Dynamic Control Allocation",p={unversionedId:"hardware/px4-firmware/px4-dynamic-control-allocation",id:"hardware/px4-firmware/px4-dynamic-control-allocation",isDocsHomePage:!1,title:"PX4 Dynamic Control Allocation",description:"Introduction",source:"@site/docs/hardware/px4-firmware/px4-dynamic-control-allocation.md",sourceDirName:"hardware/px4-firmware",slug:"/hardware/px4-firmware/px4-dynamic-control-allocation",permalink:"/tech-details/docs/hardware/px4-firmware/px4-dynamic-control-allocation",version:"current",lastUpdatedAt:1628956952,formattedLastUpdatedAt:"8/14/2021",frontMatter:{hide_title:!0,sidebar_label:"PX4 Dynamic Control Allocation"},sidebar:"px4firmwareSidebar",previous:{title:"Hardware Camera Trigger",permalink:"/tech-details/docs/hardware/px4-firmware/px4-camera-trigger"},next:{title:"PX4 FAQ",permalink:"/tech-details/docs/hardware/px4-firmware/px4-FAQ"}},s=[{value:"Introduction",id:"introduction",children:[]},{value:"Overall Structure",id:"overall-structure",children:[]},{value:"SITL (Gazebo Simulation)",id:"sitl-gazebo-simulation",children:[]},{value:"Control Allocation Algorithm Implementation in Python",id:"control-allocation-algorithm-implementation-in-python",children:[]},{value:"TLab Octo-Coax Model",id:"tlab-octo-coax-model",children:[]},{value:"Problems",id:"problems",children:[{value:"How to Construct the iris_cox Gazebo Model:",id:"how-to-construct-the-iris_cox-gazebo-model",children:[]}]}],d={toc:s};function u(t){var e=t.components,i=(0,r.Z)(t,o);return(0,l.kt)("wrapper",(0,n.Z)({},d,i,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"px4-dynamic-control-allocation"},"PX4 Dynamic Control Allocation"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=xjLM9whwjO4"},"https://www.youtube.com/watch?v=xjLM9whwjO4")),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://github.com/PX4/PX4-Autopilot/pull/13351"},"https://github.com/PX4/PX4-Autopilot/pull/13351")),(0,l.kt)("h2",{id:"introduction"},"Introduction"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"control allocation",src:a(24402).Z})),(0,l.kt)("p",null,"Control allocation is a part of the PX4 system that computes the actuator commands from torque and thrust setpoints."),(0,l.kt)("p",null,"The old version of PX4 uses static mixing tables generated by mixers. A mixer uses the geometry of a vehicle to calculate an effectiveness matrix consisting of the force and torque generated by each actuator. Then the pseudo-inverse of the effectiveness matrix, aka the mixer matrix, is calculated. The mixer matrix can be multiplied with the moment and thrust setpoints to obtain the required actuator commands. All these works are done at compile time, therefore the mixing table cannot be modified during runtime. To achieve dynamic control allocation, we need to be able to change the mixing table at runtime."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"control allocation",src:a(31740).Z})),(0,l.kt)("p",null,"The new control_allocator module does so by calculating the effectiveness matrix and its inverse in the controller. Its input, torque and thrust setpoints, are calculated in the angular_velocity_controller module which uses mass and inertia parameters to get gains with physical units. It also reads parameters that indicate which rotors are disabled and updates the effectiveness matrix accordingly. To integrate these modules into the existing system, a direct mixer is used."),(0,l.kt)("h2",{id:"overall-structure"},"Overall Structure"),(0,l.kt)("details",null,(0,l.kt)("summary",null,(0,l.kt)("b",null,"angular_velocity_controller")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Calculate ",(0,l.kt)("strong",{parentName:"li"},"thrust_sp"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"thrust_sp")," = thrust ",(0,l.kt)("em",{parentName:"li"}," vm_mass ")," G / hover_thrust"))),(0,l.kt)("li",{parentName:"ol"},"Calculate ",(0,l.kt)("strong",{parentName:"li"},"torque_sp"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"angular_accel_sp = gain_p .",(0,l.kt)("em",{parentName:"li"}," angular_velocity_error - gain_d .")," angular_acceleration"),(0,l.kt)("li",{parentName:"ul"},"torque_ff = angular_velocity_int + gain_ff .* angular_velocity_sp"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"torque_sp")," = inertia ",(0,l.kt)("em",{parentName:"li"}," angular_accel_sp + torque_ff + angular_velocity x (inertia ")," angular_velocity)"),(0,l.kt)("li",{parentName:"ul"},"angular_velocity_int = angular_velocity_int + i_factor ",(0,l.kt)("em",{parentName:"li"}," gain_i ")," angular_velocity_error * dt"))),(0,l.kt)("li",{parentName:"ol"},"Publish ",(0,l.kt)("strong",{parentName:"li"},"thrust_sp")," and ",(0,l.kt)("strong",{parentName:"li"},"torque_sp"))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"AVC_*_P"),(0,l.kt)("td",{parentName:"tr",align:null},"Body * axis angular velocity P gain (unit 1/s)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"AVC_*_I"),(0,l.kt)("td",{parentName:"tr",align:null},"Body * axis angular velocity I gain (unit Nm/rad)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"AVC_*_D"),(0,l.kt)("td",{parentName:"tr",align:null},"Body * axis angular velocity D gain")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"AVC_*_I_LIM"),(0,l.kt)("td",{parentName:"tr",align:null},"Body * axis angular velocity integrator limit (unit Nm)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"AVC_*_FF"),(0,l.kt)("td",{parentName:"tr",align:null},"Body * axis angular velocity feedforward gain (unit Nm/(rad/s))")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"AVC_*_K"),(0,l.kt)("td",{parentName:"tr",align:null},"Body * axis angular velocity controller global gain")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"VM_MASS"),(0,l.kt)("td",{parentName:"tr",align:null},"Mass (unit kg)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"VM_INERTIA_XX"),(0,l.kt)("td",{parentName:"tr",align:null},"Inertia matrix, XX component (unit kg m^2)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"VM_INERTIA_YY"),(0,l.kt)("td",{parentName:"tr",align:null},"Inertia matrix, YY component (unit kg m^2)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"VM_INERTIA_ZZ"),(0,l.kt)("td",{parentName:"tr",align:null},"Inertia matrix, ZZ component (unit kg m^2)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"VM_INERTIA_XY"),(0,l.kt)("td",{parentName:"tr",align:null},"Inertia matrix, XY component (unit kg m^2)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"VM_INERTIA_XZ"),(0,l.kt)("td",{parentName:"tr",align:null},"Inertia matrix, XZ component (unit kg m^2)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"VM_INERTIA_YZ"),(0,l.kt)("td",{parentName:"tr",align:null},"Inertia matrix, YZ component (unit kg m^2)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"MPC_THR_HOVER"),(0,l.kt)("td",{parentName:"tr",align:null},"Hover thrust (Vertical thrust required to hover)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"MPC_USE_HTE"),(0,l.kt)("td",{parentName:"tr",align:null},"Hover thrust source selector (Set false to use the fixed parameter MPC_THR_HOVER Set true to use the value computed by the hover thrust estimator) see ",(0,l.kt)("a",{parentName:"td",href:"https://github.com/PX4/PX4-Autopilot/pull/13981#issue-364553361"},"this PR for details"))))),(0,l.kt)("p",null,"Reference: ",(0,l.kt)("a",{parentName:"p",href:"https://docs.px4.io/master/en/advanced_config/parameter_reference.html#angular-velocity-control"},"https://docs.px4.io/master/en/advanced_config/parameter_reference.html#angular-velocity-control"))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"uORB Subscriptions"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Topic"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"control_allocator_status"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"torque_setpoint_achieved"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"unallocated_torque[3]"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vehicle_angular_acceleration"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"xyz[3]"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vehicle_control_mode"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"flag_control_rates_enabled")," (true if rates are stabilized), ",(0,l.kt)("inlineCode",{parentName:"td"},"flag_armed"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vehicle_land_detected"),(0,l.kt)("td",{parentName:"tr",align:null},"...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vehicle_rates_setpoint"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"timestamp"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"roll"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"pitch"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"yaw"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"thrust_body[3]")," (for multicopter, ","[0]"," and ","[1]"," are usually 0 and ","[2]"," is negative throttle demand, normalized in body NED frame ","[-1, 1]",")")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vehicle_status"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"vehicle_type"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hover_thrust_estimate"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"hover_thrust")," ","[0.1, 0.9]")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vehicle_angular_velocity"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"xyz[3]")))))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"uORB Publications"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Topic"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rate_ctrl_status"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"timestamp"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"rollspeed_integ"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"pitchspeed_integ"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"yawspeed_integ"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vehicle_angular_acceleration_setpoint"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"timestamp"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"timestamp_sample"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"xyz[3]"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vehicle_thrust_setpoint"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"timestamp"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"timestamp_sample"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"xyz[3]")," (unit N)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vehicle_torque_setpoint"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"timestamp"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"timestamp_sample"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"xyz[3]")," (unit N.m)")))))),(0,l.kt)("br",null),(0,l.kt)("details",null,(0,l.kt)("summary",null,(0,l.kt)("b",null,"control_allocator")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Update effectiveness matrix (repeat for each rotor)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"thrust = ct * axis"),(0,l.kt)("li",{parentName:"ul"},"moment = ct ",(0,l.kt)("em",{parentName:"li"}," position x axis - ct ")," km * axis"),(0,l.kt)("li",{parentName:"ul"},"Put thrust and moment in effectiveness matrix"))),(0,l.kt)("li",{parentName:"ol"},"Set 0 effectiveness if act_min >= act_max in params"),(0,l.kt)("li",{parentName:"ol"},"Run allocation (pseudo-inverse)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"mix = pseudo-inverse(effectiveness)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"actuator_sp")," = mix * thrust_sp"),(0,l.kt)("li",{parentName:"ul"},"Clip ",(0,l.kt)("strong",{parentName:"li"},"actuator_sp")),(0,l.kt)("li",{parentName:"ul"},"control_allocated = effectiveness * actuator_sp"))),(0,l.kt)("li",{parentName:"ol"},"Publish ",(0,l.kt)("strong",{parentName:"li"},"actuator_sp")),(0,l.kt)("li",{parentName:"ol"},"Publish normalized actuator_sp as ",(0,l.kt)("strong",{parentName:"li"},"actuator_controls_4")," and ",(0,l.kt)("strong",{parentName:"li"},"actuator_controls_5")," for the mixer system")),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Class Diagram"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"control allocator class diagram",src:a(24859).Z})),(0,l.kt)("p",null,(0,l.kt)("a",{target:"_blank",href:a(42357).Z},"Draw.io source"))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"CA_AIRFRAME"),(0,l.kt)("td",{parentName:"tr",align:null},"0 Multirotor, 1 Standard VTOL (WIP), 2 Tiltrotor VTOL (WIP)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"CA_METHOD"),(0,l.kt)("td",{parentName:"tr",align:null},"0 Pseudo-inverse with output clipping, 1 Pseudo-inverse with sequential desaturation technique")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"CA_BAT_SCALE_EN"),(0,l.kt)("td",{parentName:"tr",align:null},"Battery power level scaler")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"CA_AIR_SCALE_EN"),(0,l.kt)("td",{parentName:"tr",align:null},"Airspeed scaler")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"CA_ACT*_MIN"),(0,l.kt)("td",{parentName:"tr",align:null},"...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"CA_ACT*_MAX"),(0,l.kt)("td",{parentName:"tr",align:null},"...")))),(0,l.kt)("p",null,"Reference: ",(0,l.kt)("a",{parentName:"p",href:"https://docs.px4.io/master/en/advanced_config/parameter_reference.html#control-allocation"},"https://docs.px4.io/master/en/advanced_config/parameter_reference.html#control-allocation"))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"uORB Subscriptions"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"battery_status"),(0,l.kt)("td",{parentName:"tr",align:null},"...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"airspeed"),(0,l.kt)("td",{parentName:"tr",align:null},"...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vehicle_status"),(0,l.kt)("td",{parentName:"tr",align:null},"...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vehicle_torque_setpoint"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"xyz[3]"),": torque setpoint along X, Y, Z body axis (in N.m)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vehicle_thrust_setpoint"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"xyz[3]"),": thrust setpoint along X, Y, Z body axis (in N)"))))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"uORB Publications"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vehicle_actuator_setpoint"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"actuator[16]"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"control_allocator_status"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"timestamp"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"allocated_torque[3]"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"allocated_thrust[3]"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"unallocated_torque[3]"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"allocated_torque[3]"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"torque_setpoint_achieved"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"thrust_setpoint_achieved"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"actuator_saturation[NUM_ACTUATORS]"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"actuator_controls_4"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"control[8]"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"actuator_controls_5"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"control[8]"))))))),(0,l.kt)("h2",{id:"sitl-gazebo-simulation"},"SITL (Gazebo Simulation)"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"# Clone the repo\ngit clone -b lirc-ca-new https://github.com/lirc572/PX4-Autopilot.git --recursive\n\ncd PX4-Autopilot\n\n\n# Run one of the make commands below to compile and start simulation:\n\n# Hexrotor x:\nmake px4_sitl_ctrlalloc gazebo_typhoon_ctrlalloc\n\n# Quadrotor Wide:\nmake px4_sitl_ctrlalloc gazebo_iris_ctrlalloc\n\n# Octorotor Coaxial:\nmake px4_sitl_ctrlalloc gazebo_iris_cox_ctrlalloc\n\n\n# Stop one motor in PX4 Shell:\nparam set CA_MC_R0_CT 0\n")),(0,l.kt)("p",null,"Commands of the control_allocator module: ",(0,l.kt)("a",{parentName:"p",href:"https://docs.px4.io/master/en/modules/modules_controller.html#description"},"https://docs.px4.io/master/en/modules/modules_controller.html#description")),(0,l.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"The ",(0,l.kt)("em",{parentName:"p"},"iris_cox")," simulation does not work as expected. See the last section of this page for details."))),(0,l.kt)("h2",{id:"control-allocation-algorithm-implementation-in-python"},"Control Allocation Algorithm Implementation in Python"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://deepnote.com/project/PX4-9lguiAoGSLeQGbSWiN-9-g/%2Fctrlalloc.ipynb"},"https://deepnote.com/project/PX4-9lguiAoGSLeQGbSWiN-9-g/%2Fctrlalloc.ipynb")),(0,l.kt)("h2",{id:"tlab-octo-coax-model"},"TLab Octo-Coax Model"),(0,l.kt)("p",null,"Incomplete Gazebo Model: ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/lirc572/PX4-SITL_gazebo/tree/2ce391f77da6949b202d4eacda6cf8013abaee9a/models/octo_cox_tlab"},"GitHub link")),(0,l.kt)("details",null,(0,l.kt)("summary",null,"init script"),(0,l.kt)("p",null,"(",(0,l.kt)("inlineCode",{parentName:"p"},"ROMFS/px4fmu_common/init.d/airframes/12001_octo_cox"),")"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"#!/bin/sh\n#\n# @name Octo Coaxial\n#\n# @type Octorotor Coaxial\n# @class Copter\n#\n# @output MAIN1 motor 1\n# @output MAIN2 motor 2\n# @output MAIN3 motor 3\n# @output MAIN4 motor 4\n# @output MAIN5 motor 5\n# @output MAIN6 motor 6\n# @output MAIN7 motor 7\n# @output MAIN8 motor 8\n#\n# @board intel_aerofc-v1 exclude\n# @board bitcraze_crazyflie exclude\n#\n\nsh /etc/init.d/rc.mc_defaults\nsh /etc/init.d/rc.ctrlalloc\n\nif [ $AUTOCNF = yes ]\nthen\n    param set MPC_XY_VEL_I_ACC 4\n    param set MPC_XY_VEL_P_ACC 3\n\n    param set RTL_DESCEND_ALT 10\n    param set RTL_LAND_DELAY 0\n\n    param set MNT_MODE_IN 0\n    param set MAV_PROTO_VER 2\n\n    param set MPC_USE_HTE 0\n\n    # Set according to actual vehicle model\n    param set VM_MASS 1.4995 # 2.05\n    param set VM_INERTIA_XX 0.018343 # 0.029125\n    param set VM_INERTIA_YY 0.019718 # 0.029125\n    param set VM_INERTIA_ZZ 0.032193 # 0.055225\n\n    param set CA_AIRFRAME 0\n    param set CA_METHOD 1\n\n    param set CA_ACT0_MIN 0.0\n    param set CA_ACT1_MIN 0.0\n    param set CA_ACT2_MIN 0.0\n    param set CA_ACT3_MIN 0.0\n    param set CA_ACT4_MIN 0.0\n    param set CA_ACT5_MIN 0.0\n    param set CA_ACT6_MIN 0.0\n    param set CA_ACT7_MIN 0.0\n    param set CA_ACT0_MAX 1.0\n    param set CA_ACT1_MAX 1.0\n    param set CA_ACT2_MAX 1.0\n    param set CA_ACT3_MAX 1.0\n    param set CA_ACT4_MAX 1.0\n    param set CA_ACT5_MAX 1.0\n    param set CA_ACT6_MAX 1.0\n    param set CA_ACT7_MAX 1.0\n\n    # KM: CCW: +ve, CW: -ve\n    # PZ: 5.5cm / 22.0cm = 0.25\n    # https://docs.px4.io/master/en/airframes/airframe_reference.html#octorotor-coaxial\n\n    param set CA_MC_R0_PX 0.7071068\n    param set CA_MC_R0_PY 0.7071068\n    param set CA_MC_R0_PZ -0.25\n    param set CA_MC_R0_CT 11.7 # 12.523\n    param set CA_MC_R0_KM 0.0137 # 0.0135\n\n    param set CA_MC_R1_PX 0.7071068\n    param set CA_MC_R1_PY -0.7071068\n    param set CA_MC_R1_PZ -0.25\n    param set CA_MC_R1_CT 11.7 # 12.523\n    param set CA_MC_R1_KM -0.0137 # -0.0135\n\n    param set CA_MC_R2_PX -0.7071068\n    param set CA_MC_R2_PY -0.7071068\n    param set CA_MC_R2_PZ -0.25\n    param set CA_MC_R2_CT 11.7 # 12.523\n    param set CA_MC_R2_KM 0.0137 # 0.0135\n\n    param set CA_MC_R3_PX -0.7071068\n    param set CA_MC_R3_PY 0.7071068\n    param set CA_MC_R3_PZ -0.25\n    param set CA_MC_R3_CT 11.7 # 12.523\n    param set CA_MC_R3_KM -0.0137 # -0.0135\n\n    param set CA_MC_R4_PX 0.7071068\n    param set CA_MC_R4_PY -0.7071068\n    param set CA_MC_R4_PZ 0.25\n    param set CA_MC_R4_CT 11.7 # 12.523\n    param set CA_MC_R4_KM 0.0137 # 0.0135\n\n    param set CA_MC_R5_PX 0.7071068\n    param set CA_MC_R5_PY 0.7071068\n    param set CA_MC_R5_PZ 0.25\n    param set CA_MC_R5_CT 11.7 # 12.523\n    param set CA_MC_R5_KM -0.0137 # -0.0135\n\n    param set CA_MC_R6_PX -0.7071068\n    param set CA_MC_R6_PY 0.7071068\n    param set CA_MC_R6_PZ 0.25\n    param set CA_MC_R6_CT 11.7 # 12.523\n    param set CA_MC_R6_KM 0.0137 # 0.0135\n\n    param set CA_MC_R7_PX -0.7071068\n    param set CA_MC_R7_PY -0.7071068\n    param set CA_MC_R7_PZ 0.25\n    param set CA_MC_R7_CT 11.7 # 12.523\n    param set CA_MC_R7_KM -0.0137 # -0.0135\nfi\n\nset MAV_TYPE 13\n\n# set MIXER octo_cox\nset MIXER direct\nset PWM_OUT 12345678\n"))),(0,l.kt)("h2",{id:"problems"},"Problems"),(0,l.kt)("p",null,"Currently the iris_cox simulation does not work as expected. The same gazebo model works with the old control allocation implementation (",(0,l.kt)("inlineCode",{parentName:"p"},"make px4_sitl gazebo_iris_cox"),") but not under the new control allocation structure."),(0,l.kt)("p",null,"With the new implementation, as long as ",(0,l.kt)("inlineCode",{parentName:"p"},"CA_ACT*_MIN")," is set to be >= ",(0,l.kt)("inlineCode",{parentName:"p"},"CA_ACT*_MAX"),", the corresponding PWM output will be set to 1500. By default all ",(0,l.kt)("inlineCode",{parentName:"p"},"CA_ACT*_MIN")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"CA_ACT*_MAX")," are set to ",(0,l.kt)("inlineCode",{parentName:"p"},"0.0"),", so any unconfigured motor will output ",(0,l.kt)("inlineCode",{parentName:"p"},"1500"),"."),(0,l.kt)("p",null,"Below are some simulation results:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"only configure R0-R3 \u2192 works"),(0,l.kt)("li",{parentName:"ul"},"only configure R4-R7 \u2192 accelerate upwards as soon as arm"),(0,l.kt)("li",{parentName:"ul"},"configure all R0-R7 \u2192 accelerate upwards as soon as arm"),(0,l.kt)("li",{parentName:"ul"},"configure R0 \u2192 okay to arm"),(0,l.kt)("li",{parentName:"ul"},"configure R4 \u2192 upsidedown"),(0,l.kt)("li",{parentName:"ul"},"configure R0-R3 + R4 \u2192 okay to arm"),(0,l.kt)("li",{parentName:"ul"},"configure R0-R3 + R5 \u2192 okay to arm"),(0,l.kt)("li",{parentName:"ul"},"configure R0-R3 + R4 + R5 \u2192 when arm, front goes up \u2192 upsidedown"),(0,l.kt)("li",{parentName:"ul"},"configure R0-R3 + R6 \u2192 okay to arm"),(0,l.kt)("li",{parentName:"ul"},"configure R0-R3 + R7 \u2192 okay to arm"),(0,l.kt)("li",{parentName:"ul"},"configure R0-R3 + R6 + R7 \u2192 when arm, front goes up \u2192 upsidedown")),(0,l.kt)("p",null,"Below are my guesses of what went wrong:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Even if the PWM output of a motor is 1500 (when left unconfigured), gazebo does not necessarily simulate the prop rotating at that speed, since the vehicle stays on the ground even if all lower 4 motors receive a PWM output of 1500."),(0,l.kt)("li",{parentName:"ul"},"There is something wrong with the gazebo motor definition, since one side of the vehicle will tilt upwards if we enable 2 lower motors at the same side even if their PWM output is only a little above 1000.")),(0,l.kt)("h3",{id:"how-to-construct-the-iris_cox-gazebo-model"},"How to Construct the iris_cox Gazebo Model:"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://github.com/lirc572/PX4-SITL_gazebo/blob/c79686bd8d796bf4e50a0ffe521999059ac174ab/models/iris_cox_ctrlalloc/iris_cox_ctrlalloc.sdf"},"https://github.com/lirc572/PX4-SITL_gazebo/blob/c79686bd8d796bf4e50a0ffe521999059ac174ab/models/iris_cox_ctrlalloc/iris_cox_ctrlalloc.sdf")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The iris_cox model is based on the original iris model in PX4-SITL_gazebo."),(0,l.kt)("li",{parentName:"ul"},"Duplicate the rotor_0 - rotor_3 links and joints, and update their name and position (as rotor_4 - rotor_7)."),(0,l.kt)("li",{parentName:"ul"},"Add 4 new ",(0,l.kt)("em",{parentName:"li"},"libgazebo_motor_model")," plugins to match the lower 4 motors."),(0,l.kt)("li",{parentName:"ul"},"Update the ",(0,l.kt)("em",{parentName:"li"},"mavlink_interface")," plugin, edit the control_channels \u2192 rotor5 - rotor8 based on rotor1 - rotor4.")))}u.isMDXComponent=!0},42357:function(t,e,a){"use strict";e.Z=a.p+"assets/files/ca-e37804e2f6c8662c2e403675f4fb7bec.drawio"},11748:function(t,e,a){var n={"./locale":89234,"./locale.js":89234};function r(t){var e=l(t);return a(e)}function l(t){if(!a.o(n,t)){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}return n[t]}r.keys=function(){return Object.keys(n)},r.resolve=l,t.exports=r,r.id=11748},24402:function(t,e,a){"use strict";e.Z=a.p+"assets/images/PX4_High-Level_Flight-Stack-9fb7a6077604093aa03e0ac3d69e8f0d.svg"},31740:function(t,e,a){"use strict";e.Z=a.p+"assets/images/ca_sequence-2e027c80bbf18981d56404abf257672f.png"},24859:function(t,e,a){"use strict";e.Z=a.p+"assets/images/control_allocation-aa7c1f77c37757ecb72609d37b9b62dd.png"}}]);