(self.webpackChunktech_details=self.webpackChunktech_details||[]).push([[6307],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return s},kt:function(){return u}});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):p(p({},t),e)),n},s=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,s=i(e,["components","mdxType","originalType","parentName"]),m=c(n),u=o,f=m["".concat(l,".").concat(u)]||m[u]||d[u]||a;return n?r.createElement(f,p(p({ref:t},s),{},{components:n})):r.createElement(f,p({ref:t},s))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,p=new Array(a);p[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,p[1]=i;for(var c=2;c<a;c++)p[c]=n[c];return r.createElement.apply(null,p)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},15577:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return s},default:function(){return m}});var r=n(22122),o=n(19756),a=(n(67294),n(3905)),p=["components"],i={hide_title:!0,sidebar_label:"stereo"},l="stereo.cpp",c={unversionedId:"research/edt/stereo",id:"research/edt/stereo",isDocsHomePage:!1,title:"stereo.cpp",description:"implement a class StereoUpdater with param",source:"@site/docs/research/edt/stereo.md",sourceDirName:"research/edt",slug:"/research/edt/stereo",permalink:"/tech-details/docs/research/edt/stereo",version:"current",lastUpdatedAt:1626243292,formattedLastUpdatedAt:"7/14/2021",frontMatter:{hide_title:!0,sidebar_label:"stereo"},sidebar:"researchSidebar",previous:{title:"Map Updater",permalink:"/tech-details/docs/research/edt/MapUpdater"},next:{title:"loop_closure Overview",permalink:"/tech-details/docs/research/msckf_vio/loop_closure"}},s=[],d={toc:s};function m(e){var t=e.components,n=(0,o.Z)(e,p);return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"stereocpp"},"stereo.cpp"),(0,a.kt)("p",null,"implement a class ",(0,a.kt)("inlineCode",{parentName:"p"},"StereoUpdater")," with param "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"    StereoUpdater::StereoUpdater(LinDistMap *dmap, DevMap *dev_map,\n                                StereoParams p):\n        MapUpdater(dmap,dev_map),\n        _sp(p)\n    {\n        allocMem(_sp.rows,_sp.cols);\n    }\n")),(0,a.kt)("p",null,"allocate, free, reallocate memory for depth and confidence on device, ",(0,a.kt)("inlineCode",{parentName:"p"},"_D_depth"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"_D_confi_map")),(0,a.kt)("p",null,"implement a function ",(0,a.kt)("inlineCode",{parentName:"p"},"makeStereoPt"),": (1) get the current camera pose (call ",(0,a.kt)("inlineCode",{parentName:"p"},"updateProjection(trans)")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"MapUpdater.cpp"),"); (2) copy depthmap and confidence into device (although confidence not used in linear distance map optimization currently); (3) call the GPU function to construct probablity map in kernel/stereo_kernel.cu"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"    \n    // Get the current camera pose\n    updateProjection(trans);\n\n    // Copty the depthmap, etc into the device\n    topic2Dmem(depthPoint,confidence_ptr);\n\n    // Start the GPU kernel to construct the probability map\n    stereo::stereoKernelWrapper(_sp,_mp,_D_depth,_D_confi_map,_dev_map);\n")),(0,a.kt)("h1",{id:"kernelstereo_kernelcu"},"kernel/stereo_kernel.cu"),(0,a.kt)("p",null,"in function ",(0,a.kt)("inlineCode",{parentName:"p"},"void stereoKernelWrapper(const StereoParams &sp, const ProjParams &mp, float *d_depth, float* d_confi_map, DevMap *dev_map)")," call the GPU kernel function ",(0,a.kt)("inlineCode",{parentName:"p"},"__global__ void stereoMapSingleUpdater(StereoParams sp, ProjParams mp,float *d_depth, DevMap dev_map, DevGeo::coord shift)"),", blks=range of z, threads=range of y"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"    const int gridSize = dev_map->updateRange.z;\n    const int blkSize = dev_map->updateRange.y;\n\n    // calculate the shift\n    DevGeo::coord shift = dev_map->pos2coord(mp.center);\n    shift.x -= dev_map->updateRange.x/2;\n    shift.y -= dev_map->updateRange.y/2;\n    shift.z -= dev_map->updateRange.z/2;\n    stereoMapSingleUpdater<<<gridSize,blkSize>>>(sp,mp,d_depth,*dev_map,shift);\n")),(0,a.kt)("p",null,"in GPU kernel function ",(0,a.kt)("inlineCode",{parentName:"p"},"stereoMapSingleUpdater"),", in each thread, loop all the range of x, convert grid coordinate to global position (call function ",(0,a.kt)("inlineCode",{parentName:"p"},"coord2pos")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"kernel/helper_mapop.cuh"),"), then transform to body frame, finally project into pixel through calling the function ",(0,a.kt)("inlineCode",{parentName:"p"},"void global2project(const DevGeo::coord &grid_crd,const ProjParams &mp, const DevMap &dev_map, const StereoParams &sp, int2 &pix, float &depth)"),", global frame using NWU. in  ",(0,a.kt)("inlineCode",{parentName:"p"},"coord2pos")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"    for (s.x = 0; s.x < dev_map.updateRange.x; ++s.x)\n    {\n        c = s + shift;\n        global2project(c,mp,dev_map,sp,pix,depth);\n")),(0,a.kt)("p",null,"do nothing for too large or too small depth and projected pixels out of image range. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"        if (depth <= 0 || depth >4.5)\n            continue;\n        if (pix.x < 0 || pix.x >= sp.cols || pix.y < 0 || pix.y >= sp.rows || pix.y >= sp.crop)\n          continue;\n")),(0,a.kt)("p",null,"Here, compare two values, depth and img_depth. depth is the existing grid after projection, img_depth is the sensor measured depth in current frame. if grid is in front of the sensor measured depth, it should be not occupied (value = 0), then send to low pass filter to update. if grid is far behind the sensor measured depth, it cannot be seen by sensor, do nothing. if the grid is near the sensor measured depth, it should be occupied (value = 1), send to low pass filter to update. the low pass filter is a function ",(0,a.kt)("inlineCode",{parentName:"p"},"lowpassOccupancy")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"kernel/helper_mapop.cuh"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"        img_depth=d_depth[sp.cols*pix.y+pix.x];\n        if (isnan(img_depth) || img_depth <= 0.21)\n          continue;\n        if (depth < img_depth - 0.21)\n        {\n            lowpassOccupancy(c, 0, 0.5, dev_map);\n        }\n        else if (depth > img_depth + 0.21)\n        {\n            // not seen do nothing\n        }\n        else\n        {\n            lowpassOccupancy(c, 255, 0.5, dev_map);\n        }\n")),(0,a.kt)("h1",{id:"kernelhelper_mapopcuh"},"kernel/helper_mapop.cuh"),(0,a.kt)("p",null,"low pass filter"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"__device__ __forceinline__ void lowpassOccupancy(const DevGeo::coord &c, float val, float beta,const DevMap &dev_map)")),(0,a.kt)("p",null,"global position to grid map coordinate"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"__device__ __forceinline__ DevGeo::coord pos2coord(const DevGeo::pos &p,const DevGeo::pos &origin, const float &gridstep)")),(0,a.kt)("p",null,"grid map coordinate to global position"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"__device__ __forceinline__ DevGeo::pos coord2pos(const DevGeo::coord & c,const DevGeo::pos &origin, const float &gridstep)")),(0,a.kt)("h1",{id:"dsstereo_kernelcu"},"dsstereo_kernel.cu"),(0,a.kt)("p",null,"difference with ",(0,a.kt)("inlineCode",{parentName:"p"},"stereo_kernel.cu"),"\nin the function ",(0,a.kt)("inlineCode",{parentName:"p"},"global2project"),", the projection of 3D point to image pixel using the double sphere fisheye camera model; add params, ",(0,a.kt)("inlineCode",{parentName:"p"},"d_min"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"d_max"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"d_thre"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"sweep_mode")))}m.isMDXComponent=!0}}]);